<!DOCTYPE html>
<html>
<head>
<title>index</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<p><link rel="stylesheet" href="./bootstrap-3.2.0-dist/css/bootstrap.min.css"><br />
<style type="text/css"> .alert-normal {color: #404040; background-color: #f5f5f5; border-color: #cccccc; } </style></p>

<script src="./jquery/jquery.1.11.1.min.js"></script>

<script src="./bootstrap-3.2.0-dist/js/bootstrap.min.js"></script>

<h1>超科学的 git 和 Github 讲座(その１)</h1>

<blockquote>
  <p>@authors <a href="https://github.com/scau-sidc/git-tutorial/graphs/contributors">github://scau-sidc/git-tutorial/contributors</a>  <br />
  @version 4.0.0-build20151215  <br />
  @license <img src="https://i.creativecommons.org/l/by/3.0/cn/80x15.png" alt="" /> CC 3.0 BY CN  <br />
  @source <a href="https://github.com/scau-sidc/git-tutorial/">github://scau-sidc/git-tutorial</a>    </p>
  
  <p>Archives<br />
  * Ver. 2014 - <a href="./index-archive-20141212.md">./index-archive-20141212.md</a></p>
</blockquote>

<h2>0. What is ...</h2>

<p>通常来说这个时候应该说下 <em>git是什么</em>, 但为了 dismystification , 这里不会展开. 有兴趣的同学请自行<a href="http://zh.wikipedia.org/wiki/Git">维基 ↗</a>.   <br />
现在, 只需要将 git 理解成 <strong>一个可以在多人环境下随时保存和合并源代码的工具</strong> 即可.  </p>

<p>Github 就是依托 git 所建立的代码托管平台/社区, 你可以在那里四处乱逛, 寻找自己想要的代码, 吐槽别人; 或者直接脑洞大开自己写个软件出来, 搞不好还会受到路过大神的加持.<br />
不过对于英语成绩不好的同学来说, Github 是个噩梦. 在本篇教程中将只涉及 Github 的仓库托管功能. 因此只需要知道 <code>Sign up</code>, <code>Sign in</code>, <code>Create Repository</code> 这几个词组的中文意思即可.<br />
提供类 Github 服务的供应商还有很多, 比如 <a href="https://git.oschina.net">OSChina Git ↗</a>(简中/EN), <a href="https://gitcafe.com/">GitCafe ↗</a>(简中/繁中/EN), <a href="http://bitbucket.org/">bitbucket ↗</a>(EN). 但在此我们建议使用 Github, 一个充分理由是 git 的作者 <a href="https://github.com/torvalds">Linus Torvalds 使用 Github ↗</a>.  </p>

<div class="alert alert-normal">千万不要问 <i>Linus Torvalds 是什么</i> , 老邝保证不打死你.</div>

<div class="alert alert-info">这里顺便推荐一部影片, <i>遇见未来 Next</i> (IMDb:<a href="http://www.imdb.com/title/tt0435705/">tt0435705</a> | <a href="http://movie.douban.com/subject/1793909/">豆瓣↗</a>). 凯奇大叔演的. 主角具有对剧情分支的并行推衍能力, 通过分支和剪枝避免自己领便当, 其工作原理和 git 类似. 可以作为本教程的参考.</div>

<h2>1. 首先, 我们需要一个工具</h2>

<p>那当然就是在自机部署一个 git 了.  </p>

<h3>on Linux</h3>

<p>一个命令搞掂:  </p>

<pre><code>apt-get install git
</code></pre>

<p>, 或者等价的包管理器指令(yum, pacman 等)<br />
, 或者通过源码编译安装(此处省略1000字)</p>

<h3>on Windows</h3>

<p>对于蓝星人来说通常如下展开:  </p>

<p><a href="http://git-scm.org/">http://git-scm.org/</a></p>

<p>然后按蓝星人的风俗一路 Next 下去, 但副主任建议如下的加点方式: </p>

<p><img src="./asset/setup-4.png" alt="" />  </p>

<p><img src="./asset/setup-6.png" alt="" />  </p>

<p><img src="./asset/setup-7.png" alt="" /></p>

<p>理由是...为了能更方便地集成到win, 以及在跨平台间兼容.  </p>

<h3>on Mac</h3>

<p>(这个请去请教部长)</p>

<h3>as of Github</h3>

<p>再重复一次, 在本教程中只使用 Github 的仓库托管功能. Github 的其余黑科技将在附录部分解说.</p>

<p>什么是仓库托管呢? 举个栗子,</p>

<p>在使用 git 之前你们写的代码都存在自己的硬盘里:<br />
老师: (夺命追魂call)"你程序写好了? 拿来我看看"<br />
你: "哦"(找U盘, 复制粘贴, 千里迢迢呈送老师台启)<br />
(翌日)<br />
老师: (夺命追魂call)"同志快醒醒你还有几行代码有bug没改"<br />
你: "哦"(翻箱倒柜找另一个U盘, 复制粘贴, 千里迢迢呈送老师台启)<br />
(Repeat)</p>

<p>通过仓库托管将项目/代码放置在 Github 后:<br />
老师: (夺命追魂call)"你程序写好了? 拿来我看看"<br />
你: "https://github.com/foo/bar"<br />
老师: "..."<br />
(翌日)<br />
老师: (夺命追魂call)"同志快醒醒你还有几行代码有bug没改"<br />
你: "哦"(更改, 提交, 上传)"改完了. 昨天那个地址."<br />
老师: "Good..."</p>

<div class="alert alert-info">比如本教程的源代码托管在 <a href="https://github.com/scau-sidc/git-tutorial">https://github.com/scau-sidc/git-tutorial</a> . 任何人都可以自助取得.</div>

<p>之后的实验需要用到 Github, <strong>请务必注册一个账号</strong>.</p>

<div class="alert alert-info"> <a href="https://github.com/scau-sidc">github://scau-sidc</a> 是 935 驻 Github 的开发者组织, 里面有很多老鬼在划水. 可以在注册完后将你的 id 发给老邝要求加入.</div>

<p><a href="https://help.github.com/categories/bootcamp/">Github官方的新手教程 ↗</a></p>

<h2>2. 心に刻んだ夢を放て!</h2>

<p><img src="./asset/72f5bfea-s.jpg" alt="" /></p>

<div class="alert alert-normal">标题出自炮姐OP <a href="http://www.xiami.com/lrc/1769196206">↗</a>, 题图出自机巧少女, 图片仅供参考.</div>

<p>当然不可能立即就碉堡到这种程度↑咯 (´・ω・｀)  </p>

<p>对于 Windows 来说, 安装 msys-git 会附赠一个 gui , 可以通过开始菜单/文件管理器的上下文菜单/<code>git gui</code> 指令来启动它.</p>

<div class="alert alert-warning">但其实老鬼们都直接用命令行, 为了能和谐装逼我们会在行文中标注对应的指令.</div>

<div class="alert alert-info">你可以通过其它第三方图形界面使用 git, 比如 <a href="http://git-scm.com/downloads/guis">官方列出的这些</a>. 但副主任在实际试用后觉得还是附赠的那个最诺基亚. </div>

<div class="alert alert-info">在 Android 上也有可用的 git 工具, 但至今为止未发现哪个特别好用的. iOS 方面请咨询部长.</div>

<p>总之我们已经启动 git 了, 大多数情况下会弹出下面这个东东:  <br />
<img src="./asset/gui-1.png" alt="" />  <br />
意思很明确, 你要新建(<code>init</code>)呢? 还是克隆(<code>clone</code>)呢? 还是打开呢?</p>

<p>今年我们选 <code>创建新的版本库</code>, 在随后的对话框中挑选一个你喜欢的位置来置放你的代码. 这里以 <code>F:/project/hello-world/</code> 为例.</p>

<p>完成后会变成以下的样子:  <br />
<img src="./asset/gui-3.png" alt="" /></p>

<div class="alert alert-normal">图文稍微有点不一样, 请不要在意这些细节 (･ω･｀)っ彡/ </div>

<p>解说:  <br />
<span class="bg-danger">左上角红色的部分</span> 表示 工作目录(Working Copy), 也就是你以传统方式写代码时(i.e. 不使用 git ), 打开项目文件夹时看到的文件集合. 仅当你新建/修改/删除文件时, 他们会被列出在这里.  <br />
<span class="bg-success">左下角绿色的部分</span> 表示 Index(或称为 缓存区, 目前没有公认的中文翻译), 是你在缓存改动准备用于提交的地方, 关于<b>提交</b>的概念将在后文详述.  <br />
<abbr title="Working Copy">WC</abbr> 和 Index 中的文件图标是可以点击的(注意我说的是图标= =b). WC 中的文件被点后会进入 Index, 表示需要缓存( <code>stage</code> )这个改动; Index 中的文件被点后会进入 WC, 表示放弃缓存这个文件的改动( <code>reset --mixed</code> );  <br />
<span class="bg-warning">右上角黄色的部分</span> 表示 差异(diff) 仅在你在点击 WC 或者 Index 中的文件名时(注意我说的是文件名= =b), 这个区域会列出这个文件改动了哪些地方.</p>

<p>右下角用来写 <b>提交说明</b> 这个也在后文讲.  </p>

<h2>3. 种一棵树最好的时间是十年前, 其次是现在</h2>

<div class="alert alert-normal">标题取自最近在知乎流行的名言, 鸡汤请小心有毒.</div>

<p>选择 菜单栏 的 <code>版本库(repository)</code> > <code>图示所有分支的历史(Visualize all barnches history)</code>, 会调用另外一个程序. 这货叫做 gitk , 大概长得像下面的样子: </p>

<p><img src="./asset/gitk-1.png" alt="" />  </p>

<div class="alert alert-normal">你打开的那个无意外只有一个绿点, 随着你的热情与爱它会慢慢成长的. 在此之前请先看这张图↑就好.</div>

<p>界面上方由线和点组成的部分称为<code>版本树(History)</code>, 按各次提交的逻辑顺序倒序排列. 这条线上的每一个小圆点表示一个 <code>提交(commit)</code>, 各种小圆点/小标签都有不同的含义:</p>

<ul>
<li><span style="color:red;">红色的小圆点 ●</span> 是当前 工作目录(WC) 发生的变更, 仅在修改/删除内容而未缓存时出现.</li>
<li><span style="color:#00ff00;">绿色的小圆点 ●</span> 表示缓存区的变更, 仅在缓存区非空时出现.(截图时没有这个怪我咯)</li>
<li><span style="color:yellow;">黄色的小圆点 ● </span> 表示 <code>HEAD</code>, 是仓库当前的状态, 通俗来说就是(打游戏时)目前读出的存档点.</li>
<li><span style="color:blue;">蓝色的小圆点 ●</span> 是已经存入仓库的提交, 这些点是不能修改的</li>
<li>至于点与点之间的线就不解释了 →_→</li>
</ul>

<p>每个点相当于(游戏的)一个存档, 可以从任何一个点读档然后任意地展开. 所有蓝点原则上无法改动, 亦无法单独地删除.</p>

<div class="alert alert-danger">因此, 请不要将无法编译的源代码/编译过程中产生的中间文件/特定于编辑器的配置文件/日志/密码/果照/爱情动作片等放到版本库中.</div>

<ul>
<li>还有 <span style="background-color:#00ff00; border:1px solid;">绿色的小标签</span> 表示 <code>分支(branch)</code> , 其中有些带有 <span style="background-color:#ffd8aa; border:1px solid black;">嫩肉色前缀</span> 的表示 <code>远程分支(remote branch)</code>. 前者是存在于此仓库的分支, 后者是存在于别的仓库的分支  </li>
<li>成熟的项目还会有 <span style="background-color:yellow; border:1px solid;">黄色的小标签</span>, 它叫做 <code>tag</code> 或者 <code>里程碑(milestone)</code>, 通常会写着类似 <span style="background-color:yellow; border:1px solid black;">1.0.0</span> 的版本号, 这是给大牛发行用的.<br />
<div class="alert alert-normal">Tag 什么的当然是起到 tag 的功能啦.(废话</div></li>
</ul>

<h3>So what?</h3>

<p><img src="./asset/git-branch-parellel.png" alt="" /></p>

<div class="alert alert-normal">Credit by <a href="http://nvie.com/about/">Vincent Driessen ↗</a>, originate from <a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/ ↗</a></div>

<p>版本树的存在意义在于, 你可以创造无数平行的小宇宙↑. 这些小宇宙有相对独立的时间线, 但相互之间可以相互干涉或者融合.<br />
版本树的每一个 ● 提交 都是独立的状态(类比成游戏的存档), 于是你可以从任一个节点读档然后继续展开. 还有一个和游戏存档类似的特性是它们可以被分发, 在其他的机器上完全地再现.<br />
而 <span style="background-color:#00ff00; border:1px solid;">分支</span> 和 <span style="background-color:yellow; border:1px solid;">Tag</span> 则起到命名标记的作用, 方便人类以视觉快速地找到某些特别的提交. 两者的区别是分支<i>通常</i>会随着提交和合并而自动演进, 而 Tag 则是完全静态的.</p>

<div class="alert alert-danger">git 具有自动垃圾回收的功能, 分支和 tag 某种意义上起着 钉子 的作用. 版本树中, 没有被钉住的叶子节点会因为 unreferenced 而被销毁. </div>

<div class="alert alert-normal">不过在这篇教程的范围内是不会涉及这种进阶操作的啦 ฅ(・ω・ฅ)</div>

<p>版本树实际存储在项目文件夹之中, 一个名为 <code>.git</code> 的隐藏文件夹里. 如果不小心删掉的话所有历史记录都将会消失.</p>

<p>随着项目的扩增, 版本树会长得...很好看. 比如工作室贡献翻译的 <a href="https://github.com/scau-sidc/vim-cheat-sheet/network">vim-cheat-sheet ↗</a> 或者工作室开发的 <a href="https://github.com/cuter44/wxpay-sdk/network">wxpay-sdk ↗</a></p>

<h2>4. 君が歌えば 僕も歌うから</h2>

<div class="alert alert-normal">标题出自银之钥OP <a href="http://www.xiami.com/lrc/1772506559">↗</a>.</div>

<p>接下来我们做的实验, 分组的.  <br />
大概 2-3 人一组, 如果你正在独自观看这篇教程, 这意味着你需要至少找一个小伙伴或者以一人分饰两角.  <br />
堂授课请使用 手心手背分组法 或者 抛硬币分组法 快速分为2-3人的小组.   </p>

<div class="alert alert-info">遵循传统以下将使用 <a href="https://en.wikipedia.org/wiki/Alice_and_Bob">Alice, Bob and Carol</a> 作为角色代名. 请自行设定 cast.</div>

<h3>实验准备</h3>

<ol>
<li>首先, 互相交换 Github ID, 写在纸上就最好了.  </li>
<li>(在上一章中你们应该都已经新建了名为 hello-world 的本地仓库了)</li>
<li>Alice 登入 Github, 点击右上角的 <span class="glyphicon glyphicon-plus"></span> → <code>New Repository</code>. 创建远程仓库.</li>
<li><code>Repository name</code> 你们喜欢就好. (这里以 <i>hello-world</i> 为例)</li>
<li>创建之后会在中间醒目的位置提示类似于 <a href="https://github.com/cuter44/hello-world.git">https://github.com/cuter44/hello-world.git</a> 的 URL, 复制它.</li>
<li>Alice, Bob 和 Carol 打开自己的 git-gui, 菜单栏 → 远端(Remote) → Add</li>
<li><code>Name</code> 填写 <i>origin</i>, <code>Location</code> 使用之前复制的值. 确定.<br />
<div class="alert alert-success">这样你们相互之间已经确定同一个同步关系了.</div><br />
<div class="alert alert-info">对于既存的仓库还可以用 <code>克隆(clone)</code>, 相当于在(在本地创建仓库, 设定 origin 为源仓库地址, 复制源仓库内容)的命令集合.</div></li>
<li>Alice 在 Github 打开自己的仓库, 选择 <span class="glyphicon glyphicon-cog"></span> Settings → <code>Collaborators</code>, 将 Bob 和 Carol 的账号加入到列表中<br />
<div class="alert alert-success">这样 Bob 和 Carol 就具有 hello-world 的写权限了.</div></li>
<li>另外还有一项必要但与主题关系不大的工作: 三个人各自在 git-gui 打开 <code>编辑(Edit)</code> → <code>选项(Options)</code>, 在最上面两栏填写自己的 <code>用户名(User name)</code> 和 <code>邮件地址(Email Address)</code>. 不必要填写与 Github 一致. git 利用这两个字段标识代码的作者, 便于项目的参与者相互之间取得联系.</li>
</ol>

<h3>提交(commit)</h3>

<p>现在可以开始写代码了.</p>

<div class="alert alert-info">之前我们说过以 `F:/project/hello-world/` 为例.</div>

<ol>
<li>Alice 打开项目的根目录 <code>F:/project/hello-world/</code></li>
<li><p>写 hello world, 比如:</p>

<pre><code>// hellow.c

#include&lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf("hello world");
    return(0);
}
</code></pre></li>
<li><p>保存, 最好顺便编译一次看写对了没有.</p></li>
<li>打开 git-gui, 文件 <code>hellow.c</code> 会出现在左上角 <code>未缓存的改动(Unstaged Changes)</code> 区域里, 表示 git 检测到你的改动了. 如果没看到, 点击下方的 <code>重新扫描(Rescan)</code>, 要求 git 检查改动.</li>
<li>点击 <code>hellow.c</code> 的图标, 它会转移到左下方的 <code>已缓存改动(Staged Changes)</code>  里.</li>
<li>逐一检查及筛选将要提交的文件, 重复以上步骤添加到 已缓存改动 中. 在这个例子里我们只有一个文件需要提交.</li>
<li><p>在下方的文本框撰写提交说明, 提交说明是用于描述此次提交对整个项目的影响, 便于其他人(也包括将来的你自己)快速地进行检索. 推荐的格式将在附录中讲述, 现在先这样填写:</p>

<pre><code>inital commit.
</code></pre>

<div class="alert alert-normal">恭喜你们当中的一部分已经拿下本工作室的成就(之一), First Blood:取得某个项目的 inital commit</div></li>
<li>现在可以点 <code>提交(commit)</code> 了<br />
<div class="alert alert-success">至此 hellow.c 就已经进入 <strong>Alice 的本地仓库</strong>了. 不信的话可以打开 gitk 确认.</div></li>
<li>在你认为你的工作成果需要共享给别人的时候, 点 <code>上传(push)</code>. <br />
<img src="./asset/gui-before-push.png" alt="" /><br />
选择 上传哪个分支(这里选 <i>master</i>), 传到哪个仓库(这里选 <i>origin</i>), 之后你们会玩的了...<br />
<div class="alert alert-success">然后更改被传送到 Github. 可以通过 Github 网页端查看, 或者(被其他人)通过 git 客户端 <code>提取(fetch)</code> 到本地仓库.</div><br />
<div class="alert alert-info">好了也差不多该告诉你们这个事实了.<br />
这里 origin 是对远程仓库的命名, 可以随便命名所以你想叫它做金鱼草或者猫好好都是可以的. 不同的机器上对同一个远程仓库取不同的名字也是可以的.<br />
不过名为 origin 的远程仓库被 git 认为是"源仓库", 对于 <code>push</code> <code>fetch</code> 等远程交换类指令在不指定目标仓库时会缺省将 origin 作为目标.<br />
</div></li>
</ol>

<div class="alert alert-warning">
为了避免如历史上的某人<!-- 我不会说是部长 -->一样产生错误的认知, 这里有必要再强调一次:
<br />
除非你亲自执行相应的指令, git 不会:
<ul>
  <li> 每 5 秒检查一次你写的代码并自动备份;
  <li> 在你按下 <kbd>^S</kbd> <kbd>:w</kbd> whatever else... 的时候自动缓存改动或者提交;
  <li> 自动将更改发到 Github 或者任何其他远程版本库中;
  <li> 在 `提取(fetch)` 操作后自动对你正在编辑的代码打补丁.
</ul>
</div>

<h3>提取(fetch), 分支(branch), 以及合作编辑</h3>

<ol>
<li>Bob 启动 git-gui, 选择 <code>远端(Remote)</code> → <code>从...提取(Fetch from)</code> → <code>origin</code></li>
<li>(等待 git 从 Github 取得 Alice 的更新)<br />
<div class="alert alert-success">至此已经从 Github 取得 Alice 的更改, 并保存在 origin/master 上. 打开 gitk 可以看到相应的变化.</div></li>
<li>选择 <code>分支(Branch)</code> → <code>Checkout</code> → <code>master</code>, 切换到 <code>master</code> 分支.</li>
<li>选择 <code>合并(Merge)</code> → <code>本地合并(Local Merge)</code>. 现在 Bob 应该处于 master 分支上, 应该会出现 <code>Merge Into master</code> 的字样.</li>
<li>选择 <code>跟踪分支(Tracking Branch)</code> → <code>origin/master</code> → <code>合并(Merge)</code>.<br />
<div class="alert alert-success">至此已经将取得的更改应用到本地, Bob 正在编辑的文件(Working Copy)会同时被修改.</div></li>
<li>选择 <code>分支(Branch)</code> → <code>新建分支(Create)</code> , 名字可以随便决定, 在此我们以 <i>branch-bob</i> 为例.<br />
<div class="alert alert-info">关于 <i>分支(Branch)</i> 的概念会在下一节讲解.</div></li>
<li><p>现在我们要写代码了: </p>

<pre><code>// HelloWorld.java

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");

        return;
    }
}
</code></pre></li>
<li><p>按上一节讲述的方法进行 <i>提交</i> 和 <i>上传</i>.</p>

<div class="alert alert-success">这样 Bob 就为项目贡献了自己的代码了, 并且这些更改已经被提交到 Github.</div></li>
</ol>

<h3>关于分支的讲解</h3>

<p>如果将版本树比作真正的树, 那分支就好比树上萌发的新芽.  <br />
上一代的版本管理工具, 比如 <a href="http://subversion.apache.org/">SVN ↗</a> , 大多是不支持"分支"这种特性的, 版本号随每次提交自增 1, 修改历史严格线性. 在这种前提下, 经常会发生 <i>冲突</i> 并且无法自动合并:  <br />
<img src="./asset/SVN_merge.png" alt="" /></p>

<div class="alert alert-normal">Credit by rice.edu, originate from <a href="https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html">https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html ↗</a></div>  

<p>至今世界上还有很多陈年项目是使用 SVN 进行版本管理的, 长年的折磨之下猿们也学会了以曲线救国的方式来模拟分支, 比如私自开小坑:<br />
<img src="./asset/SVN_branch_tag.png" alt="" /></p>

<div class="alert alert-normal">Credit by rice.edu, originate from <a href="https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html">https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html ↗</a></div>

<p>(对此我只能表示...(=^ ・ω・^=)  </p>

<p>好了我们扯回 git.<br />
如果你们已经做过需要组队完成的课程设计作业, 那你们一定进行过类似这样的流程: 拿到一个大任务(Epic) → 按人员拆分每个人负责一部分(Task &amp; Assign) → (各自完成任务) → 归集各人的成果并进行组装 → 测试装配起来的成品是否符合初期目标 → 更改部件和重新组装, 重复直至满足目标为止.  <br />
在之前的实验中我们已经完成...呃...大概第三步的工作了, 一切都很顺利. 但之后就会变成噩梦, 组长为了组装各个部件可能需要对不具合的部分进行修剪和删改. 以人力来完成会非常...蛋疼(比如思政的那些××调查报告之类).  <br />
分支为这种场景提供解决方案. 通过和队友准实时地共享工作状态, 可以解决闭门造车的问题. git 则为分支提供进一步支持, 所有人每次提交的细节(改了哪些文件的哪些行, 谁改的, 谁先谁后...)都被记录在案, git 则利用这些信息来进行自动合并或者辅助人工合并.  <br />
分支有如下一些特性:<br />
1. 和植物的芽一样, 分支可以从任意 commit 分出. 在之前实验的分支操作中, 对话框还有一个字段是 <code>Starting Revision</code>, 可以从这里选择分支点.<br />
2. 分支可以相互合并, 如果没有冲突, git 可以按预期的结果自动合并不同分支间的差异. <br />
3. 分支可以随便命名, 所以你想叫它做猫又或者九摩诃都是可以的. 一个仓库最开始的分支名字叫做 master, 这也是可以随意更改的. 通常将 master 作为主要分支, 专用于汇合所有人的提交. <br />
4. 分支在每个远程仓库中通常有一个同名的 <code>跟踪分支(Tracking Branch)</code>, 表示这个分支在另一个仓库的同位物.<br />
5. gitk中, 分支名带有<span style="background-color:#ffd8aa; border:1px solid black;">嫩肉色前缀</span>的分支表示远程分支, 表示对应跟踪分支的位置, 在 fetch 操作时自动更新. 通常无法手动更改.<br />
6. 因为跟踪分支存在于另一个仓库中, 远程分支只是跟踪分支在本地的影, 所以位于本地仓库的本体和跟踪分支在物理上是两个分支.(看不懂的请无视)<br />
7. 因为(某分支的)跟踪分支和(该跟踪分支的)远程分支其实只是影与本体的区别, 所以在无歧义的情况下通常将两者混用.  <br />
8. 一个分支(包括其跟踪分支)通常只由一个人写. 多个人写同个分支会退化成线性的情况, 最终结果是像 SVN 一样产生大量冲突.</p>

<h3>合并更改, 以及冲突(Conflict)</h3>

<p>在之前的实验中我们已经实践了一次合并(<code>origin/master</code> → <code>master</code>, 实质相同的分支相互吸收本质其实也是合并). 接下来的实验演示合并实质不同的分支(真・合并)以及解决冲突.</p>

<ol>
<li>Carol 启动 git-gui, 选择 <code>远端(Remote)</code> → <code>从...提取(Fetch from)</code> → <code>origin</code></li>
<li>(等待 git 从 Github 取得 Alice 的更新)<br />
<div class="alert alert-success">至此已经从 Github 取得 Alice 的更改, 并保存在 origin/master 上; 取得 Bob 的更改, 并保存在 <i>origin/branch-bob</i> 上</div></li>
<li>选择 <code>分支(Branch)</code> → <code>Checkout</code> → <code>master</code>, 切换到 <code>master</code> 分支.</li>
<li>选择 <code>合并(Merge)</code> → <code>本地合并(Local Merge)</code>. 现在 Carol 应该处于 master 分支上, 应该会出现 <code>Merge Into master</code> 的字样.</li>
<li>选择 <code>跟踪分支(Tracking Branch)</code> → <code>origin/master</code> → <code>合并(Merge)</code>.<br />
<div class="alert alert-success">至此已经将 Alice 的更改应用到本地, Carol 正在编辑的文件(Working Copy)会同时被修改. Bob 的更改未被引入.</div></li>
<li>选择 <code>分支(Branch)</code> → <code>新建分支(Create)</code> , 名字可以随便决定, 在此我们以 <i>branch-carol</i> 为例.<br />
<div class="alert alert-info">关于 <i>分支(Branch)</i> 的概念会在下一节讲解.</div></li>
<li><p>写代码: </p>

<pre><code>// HelloWorld.java

import java.util.Random;

public class HelloWorld {
    public static String randomString(int i) {
        Random ran = new Random(i);
        StringBuilder sb = new StringBuilder();
        while (true) {
            int k = ran.nextInt(27);
            if (k == 0)
                break;

            sb.append((char)(64 + k));
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(randomString(-229985452) + " " + randomString(-147909649));
    }
}
</code></pre></li>
<li><p>按上一节讲述的方法进行 <i>提交</i> 和 <i>上传</i>.</p></li>
</ol>

<p>在此假设 Alice 是项目组组长, 负有整合项目的职责, 接下来她需要这么做:</p>

<ol>
<li>通过 fetch 取得 <i>branch-bob</i>, 和 <i>branch-coral</i>.</li>
<li>确认处于 master 分支上, 否则使用 checkout 转移到 master 上.</li>
<li>使用 merge 将</li>
</ol>

<p>(前方仍在施工)</p>

<h2>5. Build software better, together.</h2>

<p><a href="https://octodex.github.com/collabocats/"><img src="https://octodex.github.com/images/collabocats.jpg" width="240px"></a></p>

<p>嗯, Github 的口号...<br />
很难定义 Github 是什么, 他不是单纯的软件仓库, 不是社交网络, 不是协作工具, 虽然它样样都占点边.<br />
围绕 git 的版本管理功能, 它扩展了很多好玩的功能, 使写代码变成一件相当有趣的事.(蓝星人就知道刷微博...唉)</p>

<p>好吧正题...</p>

<h3>Timeline &amp; Dashboard</h3>

<p>登录之后的第一个画面就是 Timeline, 不过通常都没啥好看的, 因为大部分信息都没有价值.</p>

<p>随便戳一个人的名字会去到他的个人主页(比如<a href="https://github.com/cuter44">副主任的</a>)左边是 biography, 自己在 settings 填写. 右侧分了好几块, 从上到下分别是:</p>

<ul>
<li>页签 切换 活动数据, 仓库列表, (那个用户的)timeline , 后两个不解释了.</li>
<li>热门仓库 显示这个用户写的热门内容.</li>
<li>贡献 显示活跃度, 某些人会喜欢把那个列表刷到全绿... 不过如果<a href="https://github.com/torvalds">参拜过 Linus 大神的 Github 帐号</a>, 呵呵.</li>
<li>然后戳上面的小格子下面会列出具体的内容.</li>
</ul>

<p>哦对了, 访问别人的主页时右上角会有 <button class="btn btn-success">Follow</button> 按钮, 不解释. </p>

<h3>Repository</h3>

<p>当遇见喜欢的 repo, 比如<a href="https://github.com/scau-sidc/git-tutorial">这篇教程</a>, 可以使用右上角有三个操作 <button class="btn btn-default">Φ Watch</button><button class="btn btn-default">★ Star</button><button class="btn btn-default">Υ Fork</button>. 它们大致对应于蓝星微博的 收藏 点赞 转发 操作, 更详细的含义请自行在<a href="https://help.github.com/">Github的帮助系统</a>搜索.<br />
旁边的数字表示 Watch/Star/Fork 这个仓库的人数, 戳进去可以看具体是谁.</p>

<h3>Issues</h3>

<p><img src="./asset/github-issue.png" alt="" /><br />
每个仓库都会附带一个轻量级的跟踪系统, 可以用于 你发现bug并且想报告给作者/向作者提问提建议/请求队友协助(比如要求新的API)/记录自己的待办事项, 用法和 teamibition 的任务版大同小异, 这里就不再展开说了.</p>

<h3>Wiki</h3>

<p><img src="./asset/github-wiki.png" alt="" /></p>

<p>如果作者愿意, 会开放并且撰写 Wiki. Wiki 通常用于弥补文档注释的不足, 用来放置用户文档或者系统文档. 不过就实际使用情况来说, 其实不是那么方便...</p>

<div class="alert alert-info">并且...像副主任这种乐于写文档的业界良心已经不多了...</div>

<h3>Pull Request</h3>

<p><img src="./asset/github-pr.png" alt="" /><br />
前面我们教了上传(push), 能使用 push 的前提条件是你对远程仓库有写权限. 举个栗子, 刚刚我们用于订外卖的仓库, 只所以强调要提前加入组织就是为了授予对仓库的写权限. 如果没有写权限而又想要往仓库推送内容的话, 就应该使用 Pull Request 操作.</p>

<div class="alert alert-info"><abbr title="Pull Request">PR</abbr> 是 Github 特有的操作.</div>

<ol>
<li>首先要将自己的分支(在这里是<code>galin</code>)上传到 Github.</li>
<li>然后登入到项目, 会看到下图的提示, 果断点<button class="btn btn-success">Compare &amp; pull request</button>.<br />
<img src="./asset/github-pre-pr.png" alt="" /></li>
<li>然后接下来的操作与 commit 类似, 它要求你给出这个 PR 的提交描述, 所以应该按提交描述的规范认真写, 完成之后按 <button class="btn btn-success">Create pull request</button>.  </li>
<li>(跳转到PR详情页面), 整个页面包含了 你写的 PR 摘要, 包含的 commit, 文件的diff</li>
</ol>

<p>然后仓库的主人和这个 PR 的责任者会收到邮件. 然后他会检查你的 PR, 从而选择接受或者拒绝你的提交. 到这里 PR 就完成了, 界面看上去会变成题图的样子.</p>

<p>PR 的应用场景包括但不限于以下几种:  </p>

<ul>
<li>从仓库外(别人fork你的)接受提交</li>
<li>同一个工作组中, 有一个大牛做负责人, 大牛规定所有代码要由他过目才能汇集到主分支.</li>
<li>自己给自己发 PR(当备忘使用)</li>
</ul>

<h3>Github Pages</h3>

<p>就是你正在看这篇教程所依赖的托管服务了, 它会将当前目录的 <code>gh-pages</code> 发布成静态网站. 并且支持一种名为 <a href="http://jekyllrb.com/">jekyll</a> 的脚本语言. 嗯...然后, 你懂的.  Where there is an API, there is a way.<br />
比如<a href="http://scau-sidc.github.io/">本工作室的博客</a>就是几只大牛<del>利用业余时间</del>受老邝所迫撸出来的.</p>

<h3>Gist</h3>

<p><img src="./asset/gist.png" alt="" /><br />
经常会有一些小脚本你想抄起来以后用, 但它本身的规模又没大到需要专门建个仓库去安置它.  <br />
Gist就是用来满足这种需求的. 随手写, 随时用, 闲得慌了还能"手气不错"一下.</p>

<h2>6. 某超科学的<del>附录</del>黑历史</h2>

<h3>超科学的提交描述文法</h3>

<p>最开始工作室开荒的时候, 大家都不是很懂, 于是提交描述各种乱来...</p>

<pre><code>整合
</code></pre>

<p>↑ 整合了啥没说, 还是要翻代码</p>

<p>有时还会看到些嘲讽向的:</p>

<pre><code>没修改什么
</code></pre>

<p>没修改什么你交个毛线!! (＃°д°)</p>

<p>于是乎, 久病成良医, 慢慢地琢磨出一套标准:  </p>

<pre><code>登录/激活功能追加完成

+ Web API, 详情请参见javadoc
  + /authorize/register
    ! 现在还不能发邮件, 但是会通过json返回激活之必要参数
  + /authorize/activate
  * /authorize/login
    + 追加了样例
  * /authorize/logout
    + 追加了样例
  * /authorize/getRsaKey
+ 追加Criteria机能, 详请参考wiki:Criteria
+ 追加了用于RSA加密的实用工具, 详请参考wiki:服务器部署指南
</code></pre>

<p>提交的标题不说了, 很容易就能总结出来.<br />
然后下面以树状的方式列出更新的内容. 前导的符号表示更新的类型, <code>+</code> 表示新增, <code>*</code> 表示修改, <code>-</code> 表示删除, 这些和 <code>git diff</code> 的表示法相容. 需要额外注意的内容则用 <code>!</code> 表示.</p>

<h3>超科学的分支命名法</h3>

<p>有一些约定俗成的命名规则:</p>

<ul>
<li>如果你的仓库是以 <code>git clone</code> 拷贝回来的, 那么源仓库会被命名为 origin, 也就是 本源 的意思, 在命令行执行 <code>git fetch</code> <code>git push</code> 且没有指定远程仓库的名字时, 会默认使用这个.</li>
<li>主分支通常命名为 <code>master</code>, 用于存放用于发布的稳定版本. 且作为<a href="http://baike.baidu.com/view/2113289.htm">软件基线</a>(发布基线).</li>
<li>通常会有一个开发分支 <code>develop</code>, 用于收集和积淀开发过程中的功能性更新, 且作为软件基线(开发基线). 通常这两个基线的每一个提交都要求是完备的, i.e. 能够正确编译且通过全部测试用例(不过工作室一直以来都没测试管理, 所以说了也白说...).</li>
<li>然后...没了, 更规范的实践推荐看这个<a href="http://nvie.com/posts/a-successful-git-branching-model/"><i>A successful Git branching model</i></a> By <i>Vincent Driessen</i> (<a href="http://segmentfault.com/a/1190000000434973"><i>git分支最佳实践</i></a> 由 SegmentFault 翻译)   </li>
</ul>

<hr />

<p>后记</p>

<p>妈蛋这又不是轻小说写毛线后记(╯‵д′)╯︵┻━┻<br />
进阶版再说吧...</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
