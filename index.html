<!DOCTYPE html>
<html>
<head>
<title>index</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<p><link rel="stylesheet" href="./bootstrap-3.2.0-dist/css/bootstrap.min.css"><br />
<style type="text/css"> .alert-normal {color: #404040; background-color: #f5f5f5; border-color: #cccccc; } </style><br />
<style type="text/css"> img { box-shadow: 2px 4px 4px 2px #a0a0a0; } </style></p>

<script src="./jquery/jquery.1.11.1.min.js"></script>

<script src="./bootstrap-3.2.0-dist/js/bootstrap.min.js"></script>

<h1>超科学的 git 和 Github 讲座(その１)</h1>

<blockquote>
  <p>@authors @<a href="https://github.com/scau-sidc/git-tutorial/graphs/contributors">github://scau-sidc/git-tutorial/contributors</a>  <br />
  @version 4.1.1-build20151231  <br />
  @license <img src="https://i.creativecommons.org/l/by/3.0/cn/80x15.png" alt="" /> CC 3.0 BY CN  <br />
  @source <a href="https://github.com/scau-sidc/git-tutorial/">github://scau-sidc/git-tutorial</a>    </p>
  
  <p>Archives<br />
  * Ver. 2014 - <a href="./index-archive-20141212.html">./index-archive-20141212.html</a></p>
</blockquote>

<h2>0. What is ...</h2>

<p>通常来说这个时候应该说下 <em>git是什么</em>, 但为了 dismystification , 这里不会展开. 有兴趣的同学请自行<a href="http://zh.wikipedia.org/wiki/Git">维基 ↗</a>.   <br />
现在, 只需要将 git 理解成 <strong>一个可以在多人环境下随时保存和合并源代码的工具</strong> 即可.  </p>

<p>Github 就是依托 git 所建立的代码托管平台/社区, 你可以在那里四处乱逛, 寻找自己想要的代码, 吐槽别人; 或者直接脑洞大开自己写个软件出来, 搞不好还会受到路过大神的加持.<br />
不过对于英语成绩不好的同学来说, Github 是个噩梦. 在本篇教程中将只涉及 Github 的仓库托管功能. 因此只需要知道 <code>Sign up</code>, <code>Sign in</code>, <code>Create Repository</code> 这几个词组的中文意思即可.<br />
提供类 Github 服务的供应商还有很多, 比如 <a href="https://git.oschina.net">OSChina Git ↗</a>(简中/EN), <a href="https://gitcafe.com/">GitCafe ↗</a>(简中/繁中/EN), <a href="http://bitbucket.org/">bitbucket ↗</a>(EN), <a href="https://coding.net/">coding.net ↗</a>(简中). 但在此我们建议使用 Github, 一个充分理由是 git 的作者 <a href="https://github.com/torvalds">Linus Torvalds 使用 Github ↗</a>.  </p>

<div class="alert alert-normal">千万不要问 <i>Linus Torvalds 是什么</i> , 老邝保证不打死你.</div>

<div class="alert alert-info">这里顺便推荐一部影片, <i>遇见未来 Next</i> (IMDb:<a href="http://www.imdb.com/title/tt0435705/">tt0435705</a> | <a href="http://movie.douban.com/subject/1793909/">豆瓣↗</a>). 凯奇大叔演的. 主角具有对剧情分支的并行推衍能力, 通过分支和剪枝避免自己领便当, 其工作原理和 git 类似. 可以作为本教程的参考.</div>

<h2>1. 首先, 我们需要一个工具</h2>

<p>那当然就是在自机部署一个 git 了.  </p>

<h3>on Linux</h3>

<p>一个命令搞掂:  </p>

<pre><code>apt-get install git
</code></pre>

<p>, 或者等价的包管理器指令(yum, pacman 等)<br />
, 或者通过源码编译安装(此处省略1000字)</p>

<h3>on Windows</h3>

<p>对于蓝星人来说通常如下展开:  </p>

<p><a href="http://git-scm.org/">http://git-scm.org/</a></p>

<p>然后按蓝星人的风俗一路 Next 下去, 但副主任建议如下的加点方式: </p>

<p><img src="./asset/setup-4.png" alt="" />  </p>

<p><img src="./asset/setup-6.png" alt="" />  </p>

<p><img src="./asset/setup-7.png" alt="" /></p>

<p>理由是...为了能更方便地集成到win, 以及在跨平台间兼容.  </p>

<h3>on Mac</h3>

<p>(这个请去请教部长)</p>

<h3>as of Github</h3>

<p>再重复一次, 在本教程中只使用 Github 的仓库托管功能. Github 的其余黑科技将在附录部分解说.</p>

<p>什么是仓库托管呢? 举个栗子,</p>

<p>在使用 git 之前你们写的代码都存在自己的硬盘里:<br />
老师: (夺命追魂call)"你程序写好了? 拿来我看看"<br />
你: "哦"(找U盘, 复制粘贴, 千里迢迢呈送老师台启)<br />
(翌日)<br />
老师: (夺命追魂call)"同志快醒醒你还有几行代码有bug没改"<br />
你: "哦"(翻箱倒柜找另一个U盘, 复制粘贴, 千里迢迢呈送老师台启)<br />
(Repeat)</p>

<p>通过仓库托管将项目/代码放置在 Github 后:<br />
老师: (夺命追魂call)"你程序写好了? 拿来我看看"<br />
你: "https://github.com/foo/bar"<br />
老师: "..."<br />
(翌日)<br />
老师: (夺命追魂call)"同志快醒醒你还有几行代码有bug没改"<br />
你: "哦"(更改, 提交, 上传)"改完了. 昨天那个地址."<br />
老师: "Good..."</p>

<div class="alert alert-info">比如本教程的源代码托管在 <a href="https://github.com/scau-sidc/git-tutorial">https://github.com/scau-sidc/git-tutorial</a> . 任何人都可以自助取得.</div>

<p>之后的实验需要用到 Github, <strong>请务必注册一个账号</strong>.</p>

<div class="alert alert-info"> <a href="https://github.com/scau-sidc">github://scau-sidc</a> 是 935 驻 Github 的开发者组织, 里面有很多老鬼在划水. 可以在注册完后将你的 id 发给老邝要求加入.</div>

<p><a href="https://help.github.com/categories/bootcamp/">Github官方的新手教程 ↗</a></p>

<h2>2. 心に刻んだ夢を放て!</h2>

<p><img src="./asset/72f5bfea-s.jpg" alt="" /></p>

<div class="alert alert-normal">标题出自炮姐OP <a href="http://www.xiami.com/lrc/1769196206">↗</a>, 题图出自机巧少女, 图片仅供参考.</div>

<p>当然不可能立即就碉堡到这种程度↑咯 (´・ω・｀)  </p>

<p>对于 Windows 来说, 安装 msys-git 会附赠一个 gui , 可以通过开始菜单/文件管理器的上下文菜单/<code>git gui</code> 指令来启动它.</p>

<div class="alert alert-warning">但其实老鬼们都直接用命令行, 为了能和谐装逼我们会在行文中标注对应的指令.</div>

<div class="alert alert-info">你可以通过其它第三方图形界面使用 git, 比如 <a href="http://git-scm.com/downloads/guis">官方列出的这些</a>. 但副主任在实际试用后觉得还是附赠的那个最诺基亚. </div>

<div class="alert alert-info">在 Android 上也有可用的 git 工具, 但至今为止未发现哪个特别好用的. iOS 方面请咨询部长.</div>

<p>总之我们已经启动 git 了, 大多数情况下会弹出下面这个东东:  </p>

<p><img src="./asset/gui-1.png" alt="" />  </p>

<p>意思很明确, 你要新建(<code>init</code>)呢? 还是克隆(<code>clone</code>)呢? 还是打开呢?</p>

<p>今年我们选 <code>创建新的版本库</code>, 在随后的对话框中挑选一个你喜欢的位置来置放你的代码. 这里以 <code>F:/project/hello-world/</code> 为例.</p>

<p>完成后会变成以下的样子:  </p>

<p><img src="./asset/gui-3.png" alt="" /></p>

<div class="alert alert-normal">图文稍微有点不一样, 请不要在意这些细节 (･ω･｀)っ彡/ </div>

<p>解说:  <br />
<span class="bg-danger">左上角红色的部分</span> 表示 工作目录(Working Copy), 也就是你以传统方式写代码时(i.e. 不使用 git ), 打开项目文件夹时看到的文件集合. 仅当你新建/修改/删除文件时, 他们会被列出在这里.  <br />
<span class="bg-success">左下角绿色的部分</span> 表示 Index(或称为 缓存区, 目前没有公认的中文翻译), 是你在缓存改动准备用于提交的地方, 关于<b>提交</b>的概念将在后文详述.  <br />
<abbr title="Working Copy">WC</abbr> 和 Index 中的文件图标是可以点击的(注意我说的是图标= =b). WC 中的文件被点后会进入 Index, 表示需要缓存( <code>Carol</code> )这个改动; Index 中的文件被点后会进入 WC, 表示放弃缓存这个文件的改动( <code>reset --mixed</code> );  <br />
<span class="bg-warning">右上角黄色的部分</span> 表示 差异(diff) 仅在你在点击 WC 或者 Index 中的文件名时(注意我说的是文件名= =b), 这个区域会列出这个文件改动了哪些地方.</p>

<p>右下角用来写 <b>提交说明</b> 这个也在后文讲.  </p>

<h2>3. 种一棵树最好的时间是十年前, 其次是现在</h2>

<div class="alert alert-normal">标题取自最近在知乎流行的名言, 鸡汤请小心有毒.</div>

<p>选择 菜单栏 的 <code>版本库(repository)</code> > <code>图示所有分支的历史(Visualize all barnches history)</code>, 会调用另外一个程序. 这货叫做 gitk , 大概长得像下面的样子: </p>

<p><img src="./asset/gitk-1.png" alt="" />  </p>

<div class="alert alert-normal">你打开的那个无意外只有一个绿点, 随着你的热情与爱它会慢慢成长的. 在此之前请先看这张图↑就好.</div>

<p>界面上方由线和点组成的部分称为<code>版本树(History)</code>, 按各次提交的逻辑顺序倒序排列. 这条线上的每一个小圆点表示一个 <code>提交(commit)</code>, 各种小圆点/小标签都有不同的含义:</p>

<ul>
<li><span style="color:red;">红色的小圆点 ●</span> 是当前 工作目录(WC) 发生的变更, 仅在修改/删除内容而未缓存时出现.</li>
<li><span style="color:#00ff00;">绿色的小圆点 ●</span> 表示缓存区的变更, 仅在缓存区非空时出现.(截图时没有这个怪我咯)</li>
<li><span style="color:yellow;">黄色的小圆点 ● </span> 表示 <code>HEAD</code>, 是仓库当前的状态, 通俗来说就是(打游戏时)目前读出的存档点.</li>
<li><span style="color:blue;">蓝色的小圆点 ●</span> 是已经存入仓库的提交, 这些点是不能修改的</li>
<li>至于点与点之间的线就不解释了 →_→</li>
</ul>

<p>每个点相当于(游戏的)一个存档, 可以从任何一个点读档然后任意地展开. 所有蓝点原则上无法改动, 亦无法单独地删除.</p>

<div class="alert alert-danger">因此, 请不要将无法编译的源代码/编译过程中产生的中间文件/特定于编辑器的配置文件/日志/密码/果照/爱情动作片等放到版本库中.</div>

<ul>
<li>还有 <span style="background-color:#00ff00; border:1px solid;">绿色的小标签</span> 表示 <code>分支(branch)</code> , 其中有些带有 <span style="background-color:#ffd8aa; border:1px solid black;">嫩肉色前缀</span> 的表示 <code>远程分支(remote branch)</code>. 前者是存在于此仓库的分支, 后者是存在于别的仓库的分支  </li>
<li>成熟的项目还会有 <span style="background-color:yellow; border:1px solid;">黄色的小标签</span>, 它叫做 <code>tag</code> 或者 <code>里程碑(milestone)</code>, 通常会写着类似 <span style="background-color:yellow; border:1px solid black;">1.0.0</span> 的版本号, 这是给大牛发行用的.<br />
<div class="alert alert-normal">Tag 什么的当然是起到 tag 的功能啦.(废话</div></li>
</ul>

<h3>So what?</h3>

<p><img src="./asset/git-branch-parellel.png" alt="" /></p>

<div class="alert alert-normal">Credit by <a href="http://nvie.com/about/">Vincent Driessen ↗</a>, originate from <a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/ ↗</a></div>

<p>版本树的存在意义在于, 你可以创造无数平行的小宇宙↑. 这些小宇宙有相对独立的时间线, 但相互之间可以相互干涉或者融合.<br />
版本树的每一个 ● 提交 都是独立的状态(类比成游戏的存档), 于是你可以从任一个节点读档然后继续展开. 还有一个和游戏存档类似的特性是它们可以被分发, 在其他的机器上完全地再现.<br />
而 <span style="background-color:#00ff00; border:1px solid;">分支</span> 和 <span style="background-color:yellow; border:1px solid;">Tag</span> 则起到命名标记的作用, 方便人类以视觉快速地找到某些特别的提交. 两者的区别是分支<i>通常</i>会随着提交和合并而自动演进, 而 Tag 则是完全静态的.</p>

<div class="alert alert-danger">git 具有自动垃圾回收的功能, 分支和 tag 某种意义上起着 钉子 的作用. 版本树中, 没有被钉住的叶子节点会因为 unreferred 而被销毁. </div>

<div class="alert alert-normal">不过在这篇教程的范围内是不会涉及这种进阶操作的啦 ฅ(・ω・ฅ)</div>

<p>版本树实际存储在项目文件夹之中, 一个名为 <code>.git</code> 的隐藏文件夹里. 如果不小心删掉的话所有历史记录都将会消失.</p>

<p>随着项目的扩增, 版本树会长得...很好看. 比如工作室贡献翻译的 <a href="https://github.com/scau-sidc/vim-cheat-sheet/network">vim-cheat-sheet ↗</a> 或者工作室开发的 <a href="https://github.com/cuter44/wxpay-sdk/network">wxpay-sdk ↗</a></p>

<h2>4. 君が歌えば 僕も歌うから</h2>

<div class="alert alert-normal">标题出自银之钥OP <a href="http://www.xiami.com/lrc/1772506559">↗</a>.</div>

<p>接下来我们做的实验, 分组的.  <br />
大概 2-3 人一组, 如果你正在独自观看这篇教程, 这意味着你需要至少找一个小伙伴或者以一人分饰两角.  <br />
堂授课请使用 手心手背分组法 或者 抛硬币分组法 快速分为2-3人的小组.   </p>

<div class="alert alert-info">遵循传统以下将使用 <a href="https://en.wikipedia.org/wiki/Alice_and_Bob">Alice, Bob and Carol ↗</a> 作为角色代名. 请自行商讨由谁分别扮演这三个角色.</div>

<h3>实验准备</h3>

<ol>
<li>首先, 互相交换 Github ID, 写在纸上就最好了.  </li>
<li>(在上一章中你们应该都已经新建了名为 hello-world 的本地仓库了)</li>
<li>Alice 登入 Github, 点击右上角的 <span class="glyphicon glyphicon-plus"></span> → <code>New Repository</code>. 创建远程仓库.</li>
<li><code>Repository name</code> 你们喜欢就好. (这里以 <i>hello-world</i> 为例)</li>
<li>创建之后会在中间醒目的位置提示类似于 <a href="https://github.com/cuter44/hello-world.git">https://github.com/cuter44/hello-world.git</a> 的 URL, 复制它.</li>
<li>Alice, Bob 和 Carol 打开自己的 git-gui, 菜单栏 → 远端(Remote) → Add</li>
<li><code>Name</code> 填写 <i>origin</i>, <code>Location</code> 使用之前复制的值. 确定.<br />
<div class="alert alert-success">这样你们相互之间已经确定同一个同步关系了.</div><br />
<div class="alert alert-info">对于既存的仓库还可以用 <code>克隆(clone)</code>, 相当于在(在本地创建仓库, 设定 origin 为源仓库地址, 复制源仓库内容)的命令集合.</div></li>
<li>Alice 在 Github 打开自己的仓库, 选择 <span class="glyphicon glyphicon-cog"></span> Settings → <span class="glyphicon glyphicon-user"></span> Collaborators, 将 Bob 和 Carol 的账号加入到列表中<br />
<div class="alert alert-success">这样 Bob 和 Carol 就具有 hello-world 的写权限了.</div></li>
<li>另外还有一项必要但与主题关系不大的工作: 三个人各自在 git-gui 打开 <code>编辑(Edit)</code> → <code>选项(Options)</code>, 在最上面两栏填写自己的 <code>用户名(User name)</code> 和 <code>邮件地址(Email address)</code>. 不必要填写与 Github 一致. git 利用这两个字段标识代码的作者, 便于项目的参与者相互之间取得联系.</li>
</ol>

<h3>提交(commit)</h3>

<p>现在可以开始写代码了.</p>

<div class="alert alert-info">之前我们说过以 `F:/project/hello-world/` 为例.</div>

<ol>
<li>Alice 打开项目的根目录 <code>F:/project/hello-world/</code></li>
<li><p>写 hello world, 比如:</p>

<pre><code>// hellow.c

#include&lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf("hello world");
    return(0);
}
</code></pre></li>
<li><p>保存, 最好顺便编译一次看写对了没有.</p></li>
<li>打开 git-gui, 文件 <code>hellow.c</code> 会出现在左上角 <code>未缓存的改动(UnCarold Changes)</code> 区域里, 表示 git 检测到你的改动了. 如果没看到, 点击下方的 <code>重新扫描(Rescan)</code>, 要求 git 检查改动.</li>
<li>点击 <code>hellow.c</code> 的图标, 它会转移到左下方的 <code>已缓存改动(Staged Changes)</code>  里.</li>
<li>逐一检查及筛选将要提交的文件, 重复以上步骤添加到 已缓存改动 中. 在这个例子里我们只有一个文件需要提交.</li>
<li><p>在下方的文本框撰写提交说明, 提交说明是用于描述此次提交对整个项目的影响, 便于其他人(也包括将来的你自己)快速地进行检索. 推荐的格式将在<a href="#appendix-commit-msg">附录</a>中讲述, 现在先这样填写:</p>

<pre><code>inital commit.
</code></pre>

<div class="alert alert-normal">恭喜你们之中饰演 Alice 的童鞋已经拿下本工作室的成就(之一), <br /><i>First Blood</i>:取得某个项目的 inital commit</div></li>
<li>现在可以点 <code>提交(commit)</code> 了<br />
<div class="alert alert-success">至此 hellow.c 就已经进入 <strong>Alice 的本地仓库</strong>了. 不信的话可以打开 gitk 确认.</div></li>
<li>在你认为你的工作成果需要共享给别人的时候, 点 <code>上传(push)</code>. <br />
<img src="./asset/gui-before-push.png" alt="" /><br />
选择 上传哪个分支(这里选 <i>master</i>), 传到哪个仓库(这里选 <i>origin</i>), 之后你们会玩的了...<br />
<div class="alert alert-success">然后更改被传送到 Github. 可以通过 Github 网页端查看, 或者(被其他人)通过 git 客户端 <code>提取(fetch)</code> 到本地仓库.</div><br />
<div class="alert alert-info">好了也差不多该告诉你们这个事实了.<br />
这里 origin 是对远程仓库的命名, 可以随便命名所以你想叫它做金鱼草或者猫好好都是可以的. 不同的机器上对同一个远程仓库取不同的名字也是可以的.<br />
不过名为 origin 的远程仓库被 git 认为是"源仓库", 对于 <code>push</code> <code>fetch</code> 等远程交换类指令在不指定目标仓库时会缺省将 origin 作为目标.<br />
</div></li>
</ol>

<div class="alert alert-warning">
为了避免如历史上的某人<!-- 我不会说是部长 -->一样产生错误的认知, 这里有必要再强调一次:
<br />
除非你亲自执行相应的指令, git 不会:
<ul>
  <li> 每 5 秒检查一次你写的代码并自动备份;
  <li> 在你按下 <kbd>^S</kbd> <kbd>:w</kbd> whatever else... 的时候自动缓存改动或者提交;
  <li> 自动将更改发到 Github 或者任何其他远程版本库中;
  <li> 在 `提取(fetch)` 操作后自动对你正在编辑的代码打补丁.
</ul>
</div>

<h3>提取(fetch), 分支(branch), 以及合作编辑</h3>

<ol>
<li>Bob 启动 git-gui, 选择 <code>远端(Remote)</code> → <code>从...提取(Fetch from)</code> → <code>origin</code></li>
<li>(等待 git 从 Github 取得 Alice 的更新)<br />
<div class="alert alert-success">至此已经从 Github 取得 Alice 的更改, 并保存在 origin/master 上. 打开 gitk 可以看到相应的变化.</div></li>
<li>选择 <code>分支(Branch)</code> → <code>Checkout</code> → <code>master</code>, 切换到 <code>master</code> 分支.</li>
<li>选择 <code>合并(Merge)</code> → <code>本地合并(Local Merge)</code>. 现在 Bob 应该处于 master 分支上, 应该会出现 <code>Merge Into master</code> 的字样.</li>
<li>选择 <code>跟踪分支(Tracking Branch)</code> → <code>origin/master</code> → <code>合并(Merge)</code>.<br />
<div class="alert alert-success">至此已经将取得的更改应用到本地, Bob 正在编辑的文件(Working Copy)会同时被修改.</div></li>
<li>选择 <code>分支(Branch)</code> → <code>新建分支(Create)</code> , 名字可以随便决定, 在此我们以 <i>branch-bob</i> 为例.<br />
<div class="alert alert-info">关于 <i>分支(Branch)</i> 的概念会在下一节讲解.</div></li>
<li><p>现在我们要写代码了: </p>

<pre><code>// HelloWorld.java

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");

        return;
    }
}
</code></pre></li>
<li><p>按上一节讲述的方法进行 <i>提交</i> 和 <i>上传</i>.</p>

<div class="alert alert-success">这样 Bob 就为项目贡献了自己的代码了, 并且这些更改已经被提交到 Github.</div></li>
</ol>

<div class="alert alert-info">你应该已经注意到了, git 每次都要求你输入远程仓库的身份验证信息. 但其实 git 客户端(或者说通过 linux 的一些配置式约定)具有记住身份验证信息的能力, 具体如何配置请自行谷歌. 我说的是谷歌, 不是百度, 最不济也请用雅虎(国际版)或者必应(国际版).</div>

<h3>关于分支的讲解</h3>

<p>如果将版本树比作真正的树, 那分支就好比树上萌发的新芽.  <br />
上一代的版本管理工具, 比如 <a href="http://subversion.apache.org/">SVN ↗</a> , 大多是不支持"分支"这种特性的, 版本号随每次提交自增 1, 修改历史严格线性. 在这种前提下, 经常会发生 <i>冲突</i> 并且无法自动合并:  </p>

<p><img src="./asset/SVN_merge.png" alt="" /></p>

<div class="alert alert-normal">Credit by rice.edu, originate from <a href="https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html">https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html ↗</a></div>  

<p>至今世界上还有很多陈年项目是使用 SVN 进行版本管理的, 长年的折磨之下猿们也学会了以曲线救国的方式来模拟分支, 比如私自开小坑:</p>

<p><img src="./asset/SVN_branch_tag.png" alt="" /></p>

<div class="alert alert-normal">Credit by rice.edu, originate from <a href="https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html">https://www.clear.rice.edu/comp310/Eclipse/Subclipse/subversion.html ↗</a></div>

<p>(对此我只能表示...(´・ω・｀)  </p>

<p>好了我们扯回 git.<br />
如果你们已经做过需要组队完成的课程设计作业, 那你们一定进行过类似这样的流程: 拿到一个大任务(Epic) → 按人员拆分每个人负责一部分(Task &amp; Assign) → (各自完成任务) → 归集各人的成果并进行组装 → 测试装配起来的成品是否符合初期目标 → 更改部件和重新组装, 重复直至满足目标为止.  <br />
在之前的实验中我们已经完成...呃...大概第三步的工作了, 一切都很顺利. 但之后就会变成噩梦, 组长为了组装各个部件可能需要对不具合的部分进行修剪和删改. 以人力来完成会非常...蛋疼(比如思政的那些××调查报告之类).  <br />
分支为这种场景提供解决方案. 通过和队友准实时地共享工作状态, 可以解决闭门造车的问题. git 则为分支提供进一步支持, 所有人每次提交的细节(改了哪些文件的哪些行, 谁改的, 谁先谁后...)都被记录在案, git 则利用这些信息来进行自动合并或者辅助人工合并.  <br />
分支有如下一些特性:</p>

<ol>
<li>和植物的芽一样, 分支可以从任意 commit 分出. 在之前实验的分支操作中, 对话框还有一个字段是 <code>Starting Revision</code>, 可以从这里选择分支点.</li>
<li>分支可以相互合并, 如果没有冲突, git 可以按预期的结果自动合并不同分支间的差异. </li>
<li>分支可以随便命名, 所以你想叫它做猫又或者九摩诃都是可以的. 一个仓库最开始的分支名字叫做 master, 这也是可以随意更改的. 通常将 master 作为主要分支, 专用于汇合所有人的提交.</li>
<li>此外还有一个<br />
伪的"分支"名字叫做 HEAD , 它始终指向当前 checkout 的提交点.</li>
<li>分支在每个远程仓库中通常有一个同名的 <code>跟踪分支(Tracking Branch)</code>, 表示这个分支在另一个仓库的同位物.</li>
<li>gitk中, 分支名带有<span style="background-color:#ffd8aa; border:1px solid black;">嫩肉色前缀</span>的分支表示远程分支, 表示对应跟踪分支的位置, 在 fetch 操作时自动更新. 通常无法手动更改.</li>
<li>因为跟踪分支存在于另一个仓库中, 远程分支只是跟踪分支在本地的影, 所以位于本地仓库的本体和跟踪分支在物理上是两个分支.(看不懂的请无视)</li>
<li>因为(某分支的)跟踪分支和(该跟踪分支的)远程分支其实只是影与本体的区别, 所以在无歧义的情况下通常将两者混用.  </li>
<li>一个分支(包括其跟踪分支)通常只由一个人写. 多个人写同个分支会退化成线性的情况, 最终结果是像 SVN 一样产生大量冲突.</li>
</ol>

<h3>合并更改, 以及冲突(Conflict)</h3>

<p>在之前的实验中我们已经实践了一次合并(<code>origin/master</code> → <code>master</code>, 实质相同的分支相互吸收本质其实也是合并). 接下来的实验演示合并实质不同的分支(真・合并)以及解决冲突.</p>

<ol>
<li>Carol 启动 git-gui, 选择 <code>远端(Remote)</code> → <code>从...提取(Fetch from)</code> → <code>origin</code></li>
<li>(等待 git 从 Github 取得 Alice 的更新)<br />
<div class="alert alert-success">至此已经从 Github 取得 Alice 的更改, 并保存在 origin/master 上; 取得 Bob 的更改, 并保存在 <i>origin/branch-bob</i> 上</div></li>
<li>选择 <code>分支(Branch)</code> → <code>Checkout</code> → <code>master</code>, 切换到 <code>master</code> 分支.</li>
<li>选择 <code>合并(Merge)</code> → <code>本地合并(Local Merge)</code>. 现在 Carol 应该处于 master 分支上, 应该会出现 <code>Merge Into master</code> 的字样.</li>
<li>选择 <code>跟踪分支(Tracking Branch)</code> → <code>origin/master</code> → <code>合并(Merge)</code>.<br />
<div class="alert alert-success">至此已经将 Alice 的更改应用到本地, Carol 正在编辑的文件(Working Copy)会同时被修改. Bob 的更改未被引入.</div></li>
<li>选择 <code>分支(Branch)</code> → <code>新建分支(Create)</code> , 名字可以随便决定, 在此我们以 <i>branch-carol</i> 为例.<br />
<div class="alert alert-info">关于 <i>分支(Branch)</i> 的概念会在下一节讲解.</div></li>
<li><p>写代码: </p>

<pre><code>// HelloWorld.java

import java.util.Random;

public class HelloWorld {
    public static String randomString(int i) {
        Random ran = new Random(i);
        StringBuilder sb = new StringBuilder();
        while (true) {
            int k = ran.nextInt(27);
            if (k == 0)
                break;

            sb.append((char)(64 + k));
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(randomString(-229985452) + " " + randomString(-147909649));
    }
}
</code></pre>

<div class="alert alert-normal">不要问我为什么这两个神奇的数字会输出 hello world. 请自行 SO.</div></li>
<li><p>按上一节讲述的方法进行 <i>提交</i> 和 <i>上传</i>.</p></li>
</ol>

<p>在此假设 Alice 是项目组组长, 负有整合项目的职责, 接下来她需要这么做:</p>

<ol>
<li>通过 fetch 取得 <i>branch-bob</i>, 和 <i>branch-coral</i>.</li>
<li>确认处于 master 分支上, 否则通过 checkout 转移到 master 上.</li>
<li>通过 merge 将 <i>branch-bob</i> 合并到 master, 应该可以自动完成此操作.</li>
<li>通过 merge 将 <i>branch-carol</i> 合并到 master, 此时应该提示出现冲突. </li>
</ol>

<p>之所以发生冲突是因为两个人在不同的分支上都增加了 <i>HelloWorld.java</i> 这个文件, 并且 git 发现这两个操作无法被串行化. git 因为无法判断应该取舍哪些内容, 于是报告冲突, 要求人工介入.<br />
冲突的文件 <i>HelloWorld.java</i> 会显示在 git-gui 的 未缓存更改 区域, 点击文件名会显示如下的内容:</p>

<pre><code>  &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +// HelloWorld.java
 +
 +public class HelloWorld {
 +  public static void main(String[] args) {
 +    System.out.println("hello world");
 +    
 +    return;
 +  }
 +}
  =======
+ // HelloWorld.java
+ 
+ import java.util.Random;
+ 
+ public class HelloWorld {
+     public static String randomString(int i) {
+         Random ran = new Random(i);
+         StringBuilder sb = new StringBuilder();
+         while (true) {
+             int k = ran.nextInt(27);
+             if (k == 0)
+                 break;
+ 
+             sb.append((char)(64 + k));
+         }
+ 
+         return sb.toString();
+     }
+ 
+     public static void main(String[] args) {
+         System.out.println(randomString(-229985452) + " " + randomString(-147909649));
+     }
+ }
  &gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/branch-carol
</code></pre>

<p><div class="alert alert-normal">你实际看到的内容可能与上面列出的不同, 因为上面这段其实是副主任脑补出来的, 请以实际内容为准.<br />又及: 本章所有实验都是副主任脑内出来的, 副主任其实从来没有实践过本章的任何实验.(截图也是 PS 出来的(才怪</div></p>

<p>并且在 HelloWorld.java 里也是相似的内容. 这些由 git 添加的标记含义如下:</p>

<ul>
<li>每对 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 之间的块称为 Hunk. 是 git 通过比对之后分离的分歧区块.</li>
<li>每个 Hunk 内部以 <code>=======</code> 分隔合并的目标/来源分支相对于它们的共同父版本以来发生的变化.</li>
<li>为了增加分辨度在 git-gui 中以上两种以黄色显示, 是 git 自己添加上去的内容.</li>
<li>前面的 +/- 表示增加/减少了哪些行.</li>
<li>增加/减少的内容是 git 根据两个分支各自的提交记录迭代得出的, 也就是 Bob 和 Carol 写的内容.</li>
</ul>

<p>解决冲突的方法有两个:</p>

<ul>
<li>如果冲突内容比较简单, 可以在 git-gui 中右键点击文件内容, 选择要保留的行/块/回滚.</li>
<li>如果冲突内容比较复杂, 则必须用编辑器打开冲突的文件进行编辑(修改为最终需要保存的状态). 完成后要将所有的 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记删掉. github 会以此检查冲突是否都解决完了.<br />
<div class="alert alert-info">git-gui 的菜单列 <code>工具(Tools)</code> 提供了集成外部程序的能力, 可以通过配置追加直接调起外部程序(通常是编辑器)的菜单项, .</div></li>
</ul>

<p>在此假定我们要保留 Carol 的版本:</p>

<ol>
<li>用编辑器将从 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 到 <code>=======</code> 的范围删掉, 将 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 单独一行删掉.</li>
<li>保存后回到 git-gui, 要求 Rescan</li>
<li>通过和上一节相似的步骤完成 Carol commit 和 push 操作.</li>
</ol>

<p>注意我们为了演示如何解决冲突而<i>故意</i>让 Carol 制造冲突, 正确的展开应该是 Carol 注意到 Bob 添加了 HelloWorld.java 这个文件, Carol 从 master 建立 <i>branch-carol</i> 分支后, 应该先合并 <i>branch-bob</i> 然后再在 Bob 的基础上修改 HelloWorld.java .<br />
另外, 工作划分的科学性 和 程序设计的耦合度 也是影响冲突发生频度的重要因素. 理想的状况下的划分能尽量地避免触及到同一个文件, 相应地减小冲突的发生状况.</p>

<h2>5. 冃.狌.交.伖，释.鲂.压.劦、棑.解.漃.瘼 ｇi┳Ημb。ㄈ〇M</h2>

<p><img src="https://octodex.github.com/images/collabocats.jpg" width="240px"></p>

<div class="alert alert-normal">标题由总监提供, 加好苃:scauwjh。立氪撩兲; 题图来自 Github Octcat <a href="https://octodex.github.com/collabocats/">↗</a></div>

<p>Github 是目前世界最大的程序<del>猿同性交友</del>源代码托管和协作网站, 围绕 git 的版本管理功能扩展了很多好玩的功能. 突出 社交化/开源/轻量 等要素.</p>

<p>以下是为英语渣特别提供的讲解, 已经玩得很溜的同学可以跳过.</p>

<h3>Timeline &amp; Dashboard</h3>

<p>登录之后的第一个画面就是 Timeline, 不过通常都没啥好看的, 相比真・同性交友(喂)的 Timeline 来说这个也太干巴巴了.</p>

<div class="alert alert-normal">Github 标语是 be social , 但却从未在 Timeline 上下过丁点工夫. 相比之下 coding.net 在这方面做得比较有社交的味道. </div>

<p>随便戳一个人的名字会去到他的个人主页(比如<a href="https://github.com/cuter44">副主任的</a>), 左边是 biography(在 settings 中设定). 右侧分了好几块, 从上到下分别是:</p>

<ul>
<li>页签 切换 <span class="glyphicon glyphicon-plus-sign"></span> 活动数据, <span class="glyphicon glyphicon-book"></span> 仓库列表, <span class="glyphicon glyphicon-align-left"></span> (那个用户的)timeline , 后两个不解释了.</li>
<li>热门仓库 显示这个用户的受关注项目.</li>
<li>贡献 显示活跃度, 某些人有把所有格子刷到全绿的嗜好...</li>
<li>戳上面的小格子下面会列出格子对应的那一天具体的活动记录.</li>
</ul>

<p>另外在别人的主页时右上角会有 <button class="btn btn-success">_(:з」∠*)_ Follow</button> 按钮, 意思是"请收下我的<del>菊花</del>膝盖". </p>

<h3>Repository</h3>

<p>Repository 是 Github 的基本组织单元, 每个 repo 页对应着具体的仓库(比如我们刚刚一直在折腾的 <i>hello-world</i>). 通常项目作者在宣传自己项目的时候会通过粘贴 URL 或者 Widget 将访客引导到此. 另外也可以通过 搜索 和 Explore频道 在这数十万的仓库中拣选自己感兴趣的内容.</p>

<p>以 <a href="https://github.com/scau-sidc/git-tutorial">这篇教程</a> 的主页为例. 首先右上角三个操作:</p>

<ul>
<li><button class="btn btn-default">(ΦωΦ") Watch</button>: 激活后会收到仓库活动事件的通知, 比如作者有新发布, 有人提报 issue/PR, etc.</li>
<li><button class="btn btn-default">(☆ω☆") Star</button>: 激活后会将此仓库加入到你的收藏列表, 这个列表可以在你自己的 Dashboard/Profile 页面查阅, 公开显示.</li>
<li><button class="btn btn-default">ฅ(・ω・ฅ) Fork</button>: 点击后会在你/你参与的组织名下创建此仓库的派生副本. 关于派生副本请参照 <a href="https://help.github.com/articles/fork-a-repo/">Github 提供的说明</a>.</li>
</ul>

<p>按钮旁边的数字表示 Watch/Star/Fork 这个仓库的人数, 戳进去可以看具体是谁.</p>

<p>之后在页面的<del>右侧</del>(改版后位于顶部二级导航栏), 其中 <span class="glyphicon glyphicon-console"></span> Code 展示这个仓库的主页以及列出文件. 其余的板块如下所列</p>

<h3><span class="glyphicon glyphicon-exclamation-sign"></span> Issues</h3>

<p><img src="./asset/github-issue.png" alt="" /></p>

<p>每个仓库都会附带一个轻量级的跟踪系统, 可以用于 你发现 bug 并且想报告给作者/向作者提问提建议/请求队友协助(比如要求新的API)/记录自己的待办事项. 通过这里报告 bug 之后责任者和大家都能够看到, 热心的责任者可能会联络你询问 bug 的细节, 或是答复你的报告.</p>

<h3><span class="glyphicon glyphicon-list-alt"></span> Wiki</h3>

<p><img src="./asset/github-wiki.png" alt="" /></p>

<p>Wiki 就是关于这个软件如何使用的说明, 以及一些特性的解释等. 通常由仓库的责任者撰写, 对于开源项目还会有热心群众协助撰写和翻译.</p>

<h3><span class="glyphicon glyphicon-export"></span> Fork 和 <span class="glyphicon glyphicon-import"></span> Pull Request</h3>

<p><img src="./asset/github-pr.png" alt="" />                    </p>

<p>直接上传更改的必要前提是, 你必需是某个仓库的 collaborator. 但对于开源项目来说不可能将所有的潜在参与者逐一添加. 这时则通过 Fork 和 Pull Request 机制来放宽编辑条件.<br />
Fork 操作可以将他人的仓库复制一份到自己的名下. 因为这是名义上属于你的操作, 所以你具有完全的写权限. 当你完成某些修改之后, 你可以向这个仓库的原作者发送 Pull Request 提醒其检查你的更改并采纳到来源仓库中.  <br />
PR 亦可以在同仓库内进行. 比如 Bob 在完成 HelloWorld.java 后不确定其中是否有缺陷, 则他可以向 Alice 发送 PR 以提醒她在合并之前先检查一次代码.</p>

<div class="alert alert-info"><del><abbr title="Pull Request">PR</abbr> 是 Github 特有的操作.</del> PR 是 git 所不具有的机能, 由 Github 原创. 大部分托管商现在都提供了 PR 机能, 然而只有 Github 的最人性化.</div>

<ol>
<li>首先要将自己的分支(在这里是<code>galin</code>)上传到 Github.</li>
<li>然后登入到项目, 会看到下图的提示, 果断点 <button class="btn btn-success">Compare &amp; pull request</button>.<br />
<img src="./asset/github-pre-pr.png" alt="" /></li>
<li>然后接下来的操作与 commit 类似, 它要求你给出这个 PR 的提交描述, 所以应该按提交描述的规范认真写, 完成之后按 <button class="btn btn-success">Create pull request</button>.  </li>
<li>(跳转到PR详情页面), 整个页面包含了 你写的 PR 摘要, 包含的 commit, 文件的diff</li>
</ol>

<p>然后仓库的主人和这个 PR 的责任者会收到邮件. 他需要检查你的 PR, 选择接受或者拒绝该PR. 到这里 PR 就完成了, 界面看上去会变成题图的样子.</p>

<h3>Github Pages</h3>

<p>就是你正在看这篇教程所依赖的托管服务了, 它会将当前仓库里的 <code>gh-pages</code> 分支作为网站发布. 通过一种名为 <a href="http://jekyllrb.com/">jekyll</a> 的工具.<br />
比如<a href="http://scau-sidc.github.io/">本工作室的博客</a>就是几只大牛<del>利用业余时间</del>受老邝所迫撸出来的.</p>

<h3>Gist</h3>

<p><img src="./asset/gist.png" alt="" /></p>

<p>Gist 通常是因为特定目的而撰写的小段代码. 其本质也是仓库, 支持大部分仓库的操作. 但通常因为只有一两个文件于是懒得很隆重地为他们分别建立仓库.  <br />
因为部分内容包含了某些真理所以通常都会被 GFW 墙掉.<br />
比如副主任的<a href="https://gist.github.com/cuter44/9460159">正方抢课脚本</a></p>

<h2>6. 某超科学的黑历史</h2>

<h3>超科学的提交描述文法</h3>

<p><a id="appendix-commit-msg"></a></p>

<p>最开始工作室开荒的时候, 大家都不是很懂, 于是提交描述各种乱来...</p>

<pre><code>整合
</code></pre>

<p>↑ 整合了啥没说, 还是要翻代码</p>

<p>有时还会看到些嘲讽向的:</p>

<pre><code>没修改什么
</code></pre>

<p>没修改什么你交个毛线!! (＃°д°)</p>

<p>于是乎, 久病成良医, 慢慢地琢磨出一套标准:  </p>

<pre><code>登录/激活功能追加完成

+ Web API, 详情请参见javadoc
  + /authorize/register
    ! 现在还不能发邮件, 但是会通过json返回激活之必要参数
  + /authorize/activate
  * /authorize/login
    + 追加了样例
  * /authorize/logout
    + 追加了样例
  * /authorize/getRsaKey
+ 追加Criteria机能, 详请参考wiki:Criteria
+ 追加了用于RSA加密的实用工具, 详请参考wiki:服务器部署指南
</code></pre>

<p>提交的标题不说了, 很容易就能总结出来.<br />
然后下面以树状的方式列出更新的内容. 前导的符号表示更新的类型, <code>+</code> 表示新增, <code>*</code> 表示修改, <code>-</code> 表示删除, 这些和 <code>git diff</code> 的表示法相容. 需要额外注意的内容则用 <code>!</code> 表示.</p>

<h3>参考资料</h3>

<ul>
<li>为了照顾那些幽默感退化的人们, git 的本家提供了严肃的 <a href="http://git-scm.com/book/zh/v2">git 教程</a>(熟肉, 以及另外33种语言)</li>
<li>如果觉得以上两者的画风都不对, 这里还有  <a href="https://github.com/michaelliao/learngit">github://michaelliao/learngit</a> 可供食用, 附带小电影.</li>
<li>超科学的分支实践法: <a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a> by <i>Vincent Driessen</i>, 熟肉:<a href="http://segmentfault.com/a/1190000000434973">git分支最佳实践</a> by SegmentFault   </li>
<li>Github 的教育扶持计划: <a href="https://education.github.com/">Github Education</a></li>
</ul>

<h2>术语表</h2>

<p>(坑. MD 貌似不具有术语表的支持能力, 如果要写术语表貌似要手动插入大量标记. Someone help?)</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
